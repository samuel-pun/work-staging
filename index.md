 Yes, you should be concerned. This is very likely the root cause of your "package does not exist" error.

### The Problem
By default, the `spring-boot-maven-plugin` takes the standard JAR generated by Maven (which contains your accessible classes) and **repackages** it into an executable "fat JAR." In this new structure, your project's classes are moved into a `BOOT-INF/classes` directory.

*   **Executable JAR**: Great for running `java -jar my-app.jar`.
*   **Dependency**: Terrible for other modules. When `stv-cli` tries to read the `cli` JAR, it looks for classes at the root level. Because they are now hidden inside `BOOT-INF/classes`, the compiler cannot find them, resulting in "package does not exist."

### The Fix
You need to configure the `spring-boot-maven-plugin` in `cli/pom.xml` to either **skip** the repackaging (if `cli` is just a library) or generate a **separate classifier** (if `cli` needs to be both a library and executable).

#### Scenario A: `cli` is just a library (Not an executable app)
If you never run `cli` directly (i.e., it has no `main` method or you don't deploy it as a service), remove the `spring-boot-maven-plugin` or set it to skip.

```xml
<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
            <configuration>
                <skip>true</skip>
            </configuration>
        </plugin>
    </plugins>
</build>
```

#### Scenario B: `cli` is BOTH a library and an executable
If you need to run `cli` as a standalone app *and* use it as a dependency in `stv-cli`, use a classifier. This tells the plugin to keep the original (plain) JAR as the default dependency and create the executable JAR with a suffix (e.g., `-exec`).

Update `cli/pom.xml`:

```xml
<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
            <configuration>
                <!-- This creates cli-1.0.0-exec.jar for running -->
                <!-- The default cli-1.0.0.jar remains a plain library for dependencies -->
                <classifier>exec</classifier>
            </configuration>
        </plugin>
    </plugins>
</build>
```

With this change:
1.  `cli-1.0.0.jar` (Plain JAR) -> Used by `stv-cli` (Classes are at the root, compilation works).
2.  `cli-1.0.0-exec.jar` (Fat JAR) -> Used for deployment/running.

### Summary
If you leave the plugin configuration as is, `cli` is effectively "invisible" to `stv-cli` during the build because of the `BOOT-INF` relocation. **Use the classifier approach (Scenario B)** to solve this immediately while keeping the ability to run the module.[1][2]





# Why `mvn compile` works

This works because `mvn compile` operates on **classes**, not JARs.

When you run `mvn compile` from the root (or even just on the modules), Maven's reactor does the following:

1.  **Resolves Dependencies in the Reactor**: It sees that `stv-cli` depends on `cli`.
2.  **Uses Build Output Directories**: Instead of looking for a packaged JAR file (fat or otherwise), the reactor directs `stv-cli` to look directly at `cli/target/classes`.
3.  **Direct Class Access**: Since the `compile` phase happens *before* the `package` phase, the `spring-boot-maven-plugin` hasn't run yet. The classes in `cli/target/classes` are standard, unpackaged `.class` files, so `stv-cli` can read them perfectly fine.[1][2]

### Why it fails later (in `unit-test` stage)
The failure happens in the second stage because:
1.  **Persistence is File-Based**: Your pipeline likely persists the `cli/target` directory as an artifact to pass it to the next stage.
2.  **Reactor is Gone (or Reset)**: When Stage 2 starts, if it tries to resolve dependencies, it might look at the *packaged* artifact (the JAR) if the reactor state isn't perfectly preserved or if the command implies looking up dependencies.
3.  **The "Poisoned" Artifact**: By the time Stage 1 finished, the `package` phase (if it ran implicitly or explicitly) ran the Spring Boot plugin, which moved the classes into `BOOT-INF/classes` inside the JAR.
4.  **The Mismatch**: If Stage 2 tries to read the `cli.jar` (instead of the raw `target/classes` directory), it sees the "fat" structure, can't find the classes at the root, and fails.

### In Summary
*   **`mvn compile` works** because it reads raw class files from the disk before they are packaged.
*   **`mvn test` (Stage 2) fails** because it likely reads the *completed* JAR file (which is now "fat" and broken for dependency use) or fails to reconstruct the reactor's raw class path mapping.

This reinforces why **Scenario B (adding `<classifier>exec</classifier>`)** is the correct fix: it ensures that if Stage 2 ever reads the JAR file, it reads the "plain" original JAR, not the Spring Boot executable one.

來源
[1] Introduction to the Build Lifecycle - Apache Maven https://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html
[2] Maven Build Phases and Commands - GeeksforGeeks https://www.geeksforgeeks.org/advance-java/maven-build-phases-and-basic-maven-commands/
